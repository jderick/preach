#!/usr/intel/bin/perl
#
# A utility for plotting information from a preach log file.
# It can be used during preach running (i.e. while the log
# file is still in flux) or after preach completion.
# 
# usage:
# plot mymodel.log <tag> <args>
#
# this will create a file plot_<tag>.eps, and also launch ghostview (gv)
# on it.  The plot has x-axis being time (seconds) and y-axis
# being state counts, depending on the mandatory argument <tag>:
#
#  * if <tag> is wq, then the y-axis is work queue length
#  * if <tag> is ht, then the y-axis is the number of states
#    in the hash table, which is equal to the number of unique
#    reached states owned by each node.
#  * if <tag> is es, then the y-axis is the number of states
#    successfully expanded by the node.
# 
#  The nodes that are plotted are controlled by <args>:
#  
#  * if <args> = all, then all nodes are plotted
#    (this is the most common we use it)
#  * if <args> is empty, then a single node is picked at random
#  * if <args> is a non-empty list of nodes, those nodes are
#    plotted
#
# This script assumes gnuplot and gv are in your $path.
#

my $log = shift;
my $tag = shift;
($tag =~ /^(wq|ht|es)$/) || die "tag arg must be one of wq, ht, or es";
my $gtemp = "g.temptemp";

open(LOG,$log)  || die "could not open $log";
my @all_nodes;
my $random_node;

my $root;
if (1) {
  while (<LOG>) {
    if (/Starting worker thread on \w+\@(\w+) with PID (.*)/) {
      my $node = "$1.$2";
      chomp $node;
      @all_nodes = (@all_nodes,$node);
    }
  }
} else {
  while (<LOG>) {
    if (/Executed on\s+:\s+(\w+)/) {
      $root = $1;
      last;
    }
  }
  while (<LOG>) {
    if (/NB_PARALLEL_JOB_HOSTS=(.+)/) {
      @all_nodes = ($root,split(/ /,$1));
      last;
    }
  }
}

#print join("\n",@all_nodes); exit;
my @nodes;
if (! @ARGV) {
  my $i = int(rand()*(@all_nodes));
  @nodes = ($all_nodes[$i]);
  print @nodes;  print "\n";
} elsif ($ARGV[0] eq "all") {
  @nodes = @all_nodes;
} else {
  @nodes = @ARGV;
}

#
# remove duplicates from @nodes
#
my %hash   = map { $_, 1 } @nodes;	
@nodes = keys %hash;

my $eps = "plot_$tag.eps";
#my $temp = "$node.gnuplot.data";
#open(TEMP,">$temp")  || die "could not open $temp";

my %data_files;
foreach my $h (@nodes) {
  my $temp = "$h.gnuplot.data";
  open($data_files{$h},">$temp")  || die "could not open $temp";
}

close(LOG);
open(LOG,$log)  || die "could not open $log";
while (<LOG>) {
  if (/(\w+\.<\d+\.\d+.\d+>): (\d+) states expanded; (\d+) states in hash table, in (\d+) s .* (\d+) states in the queue/) {
    my $node = $1;
    my $estates = $2;
    my $hstates = $3;
    my $secs = $4;
    my $q = $5;
    if ($data_files{$node}) {
       my $FH = $data_files{$node};
       if ($tag eq 'wq') {
          print $FH "$secs $q\n";
       } elsif ($tag eq 'ht') {
          print $FH "$secs $hstates\n";
       } else {
          print $FH "$secs $estates\n";
       }
    }
  }
}

close LOG;
foreach my $h (@nodes) {
  close($data_files{$h});
}

if ($tag eq 'wq') {
   $ylabel = "Work Queue States";
} elsif ($tag eq 'ht') {
   $ylabel = "Hash Table States";
} else {
   $ylabel = "Expanded States";
}

open(GTEMP,">$gtemp")  || die "could not open $gtemp";
print GTEMP "
set nokey
set terminal postscript color
set data style lines
set ylabel \"WQ size\"
set xlabel \"Seconds\"
plot \\
"; 
for (my $i=0;$i<@nodes;$i++) {
  my $temp = $nodes[$i].".gnuplot.data";
  print GTEMP "   \"$temp\" using 1:2";
  print GTEMP ", \\" if $i < @nodes-1;
  print GTEMP "\n";
  
}
close GTEMP;

system "gnuplot $gtemp > $eps";

#unlink $temp;
#unlink $gtemp;

system "gv $eps &";


